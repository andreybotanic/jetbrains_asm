{
  parserClass = "com.andreybotanic.asm.nasm.parser.NasmParser"

  extends = "com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix = "Nasm"
  psiImplClassSuffix = "Impl"
  psiPackage = "com.andreybotanic.asm.nasm.psi"
  psiImplPackage = "com.andreybotanic.asm.nasm.psi.impl"

  elementTypeHolderClass = "com.andreybotanic.asm.nasm.psi.NasmTypes"
  elementTypeClass = "com.andreybotanic.asm.nasm.psi.NasmElementType"
  tokenTypeClass = "com.andreybotanic.asm.nasm.psi.NasmTokenType"

  psiImplUtilClass = "com.andreybotanic.asm.nasm.psi.impl.NasmPsiImplUtil"

  tokens = [
    // Most tokens I get from https://github.com/ajkhoury/JetBrains-NASM-Language/blob/master/src/com/nasmlanguage/NASM.bnf

    WHITE_SPACE         = 'regexp:[ \t\x0B\f]+'
    EOL                 = 'regexp:\R'

    // Preprocessor tags
    INCLUDE_TAG         = 'regexp:(%(\s+)?)([iI][nN][cC][lL][uU][dD][eE])'
    DEFINE_TAG          = 'regexp:(%(\s+)?)(([xX]|[iI])?[dD][eE][fF][iI][nN][eE])'
    ASSIGN_TAG          = 'regexp:(%(\s+)?)([iI]?[aA][sS][sS][iI][gG][nN])'

    DATA_DEF            = 'regexp:[dD][bBwWdDqQtToOyYzZ]'
    DATA_RES            = 'regexp:[rR][eE][sS][bBwWdDqQtToOyYzZ]'

    COMMENT             = 'regexp:;[^\r\n]*'

    SECTION_DEF         = 'regexp:section|segment'
    SECTION_NAME        = 'regexp:\.(text|data|bss)'

    DIRECTIVE_OP        = 'regexp:(bits |use|code)(16|32)|absolute|external|global|org|align|struc|endstruc|common|cpu|group|uppercase|import|library|module'
    END_DIRECTIVE_OP    = 'regexp:end'

    // Registers
    REG_8               = 'regexp:[aAbBcCdD][hHlL]'
    REG_16              = 'regexp:[aAbBcCdD][xX]'
    REG_32              = 'regexp:[eE][aAbBcCdD][xX]'
    REG_64              = 'regexp:[rR][aAbBcCdD][xX]'

    // Instruction operation prefixes
    OP_PREFIX           = 'regexp:((rep(n?[ez])|rep)|lock|bnd|xacquire|xrelease)'
    SIZE_PREFIX         = 'regexp:byte|word|dword|qword'

    JUMP_OP             = 'regexp:jmp|jn?[abceglopsz]|jn?[abgl]e|jp[eo]|j[er]?cxz'
    GENERAL_OP          = 'regexp:mov|xor|add|inc|dec|{JUMP_OP}'


    // Make last!
    ID                  = 'regexp:([a-zA-Z_?]+[a-zA-Z0-9_$.#@~?]*)' // Some identifier
    LBL_DEF             = 'regexp:([a-zA-Z$._?#@]+[a-zA-Z0-9$._~]*):' // Label definition
    LBL                 = 'regexp:([a-zA-Z$._?#@]+[a-zA-Z0-9$._~]*)' // Label can have chars like % . ? @ # ~ etc

    // Literals
    BINARY              = 'regexp:[1][01]*b'
    HEXADECIMAL         = 'regexp:(0x[0-9A-Fa-f]+)|([0-9A-Fa-f]+h)'
    ZEROES              = 'regexp:[0]+'
    DECIMAL             = 'regexp:((0[dD])?[0-9]+)'
    FLOAT_DECIMAL       = 'regexp:(([0-9]*\.[^A-Za-z][0-9]*)([Ee][+-]?[0-9]+)?)'
    CHARACTER           = "regexp:(`([^`\\]|\\.)`?|'([^'\\]|\\.)'?)"
    STRING              = "regexp:(`([^`\\]|\\.)*`?|'([^'\\]|\\.)*'?|\"([^\"\\]|\\.)*\"?)"

    COLON               = ':'
    SEMICOLON           = ';'
    SQUARE_L            = '['
    SQUARE_R            = ']'
    ROUND_L             = '('
    ROUND_R             = ')'
    CURLY_L             = '{'
    CURLY_R             = '}'
    SEPARATOR           = ','
    DOT                 = '.'
    QUESTION            = '?'

    EQUAL               = '='
    EQUALEQUAL          = '=='
    NOTEQUAL            = '!='
    GREATERTHAN         = '>'
    LESSTHAN            = '<'
    GREATERTHANOREQUAL  = '>='
    LESSTHANOREQUAL     = '<='

    PLUS                = '+'
    MINUS               = '-'
    TIMES               = '*'
    DIVIDE              = '/'
    BITSHIFT_L          = '<<'
    BITSHIFT_R          = '>>'
    BITWISE_AND         = '&'
    BITWISE_OR          = '|'
    BITWISE_XOR         = '^'
    BITWISE_NOT         = '~'
    LOGICAL_AND         = '&&'
    LOGICAL_OR          = '||'
    LOGICAL_XOR         = '^^'

    DOLLARSIGN          = '$'
    DOLLARSIGN2         = '$$'
    PERCENT             = '%'
    PERCENT2            = '%%'
    TOKEN_CONCAT        = '%+'

  ]
}

NasmFile ::= item_*

private item_ ::= BlockComment
                | COMMENT
                | Section
                | Preprocessor
                | Directive
                | MacroCall
                | InlineItem
                | EOL
                ;

Preprocessor ::= Include
               | Assign
               | Define
               ;

private InlineItem ::= Expr | Label | Instruction | DataElement | Identifier  { extends=Expr }

Include ::= INCLUDE_TAG Str
Define ::= (DEFINE_TAG Identifier DefineParams InlineItem )
         | (DEFINE_TAG Identifier InlineItem ) {
    pin         = 1
    recoverWhile= DefineRecover
    mixin       = "com.andreybotanic.asm.nasm.psi.impl.NasmNamedElementImpl"
    implements  = "com.andreybotanic.asm.nasm.psi.NasmNamedElement"
    methods     = [getName setName getNameIdentifier]
}

DefineParams ::= ROUND_L Identifier (SEPARATOR Identifier)* ROUND_R { pin=1 recoverWhile=DefineParamsRecover }
private DefineRecover ::= !(EOL | COMMENT)
private DefineParamsRecover ::= !(EOL | COMMENT | Expr)
Assign ::= ASSIGN_TAG Identifier Expr {
    pin         = 1
    mixin       = "com.andreybotanic.asm.nasm.psi.impl.NasmNamedElementImpl"
    implements  = "com.andreybotanic.asm.nasm.psi.NasmNamedElement"
    methods     = [getName setName getNameIdentifier]
}

Section ::= SECTION_DEF SECTION_NAME

Immediate ::= Expr { extends=Expr }
Memory ::= Identifier | Address
Address ::= SIZE_PREFIX? EffectiveAddress
private EffectiveAddress ::= SQUARE_L Expr SQUARE_R { pin=1 extends=Expr }

Register ::= REG_8 | REG_16 | REG_32 | REG_64 { extends=Expr }

Instruction ::= Operation Operands?

Operation ::= GENERAL_OP { extends=Expr }

private Operands ::= Operand (SEPARATOR Operand)* { pin=1 recoverWhile=OperandRecover }
private OperandRecover ::= !(COMMENT | EOL)

Operand ::= Register
          | Immediate
          | Memory
          | MacroCall
          | LabelIdentifier
          ;

Label ::= LBL_DEF {
    mixin       = "com.andreybotanic.asm.nasm.psi.impl.NasmNamedElementImpl"
    implements  = "com.andreybotanic.asm.nasm.psi.NasmNamedElement"
    methods     = [getName setName getNameIdentifier]
}

Identifier ::= ID {
    mixin       = "com.andreybotanic.asm.nasm.psi.impl.NasmNamedElementImpl"
    implements  = "com.andreybotanic.asm.nasm.psi.NasmNamedElement"
    methods     = [getName setName getNameIdentifier getReferences]
    extends     = Expr
}

LabelIdentifier ::= LBL | ID {
    mixin       = "com.andreybotanic.asm.nasm.psi.impl.NasmNamedElementImpl"
    implements  = "com.andreybotanic.asm.nasm.psi.NasmNamedElement"
    methods     = [getName setName getNameIdentifier getReferences]
    extends     = Expr
}

DataElement ::= LBL_DEF? DataStmt
DataDefStmt ::= DATA_DEF Expr (SEPARATOR Expr)* { pin=1 recoverWhile=DataValueRecover }
DataResStmt ::= DATA_RES Expr
private DataStmt ::= DataResStmt | DataDefStmt
private DataValueRecover ::= !(COMMENT | EOL)

Directive ::= DirectiveDecl | DirectiveDeclBrackets
private DirectiveDecl ::= DIRECTIVE_OP (Expr SEPARATOR?)*
private DirectiveDeclBrackets ::= SQUARE_L DIRECTIVE_OP Expr* SQUARE_R

// Math expressions
private BitShiftOp ::= BITSHIFT_L | BITSHIFT_R
private MultOp ::=TIMES | DIVIDE | PERCENT
private PlusOp ::= PLUS | MINUS
private UnaryOp ::= BITWISE_NOT | MINUS | PLUS

Primary ::= Register
          | NumericLiteral
          | Str
          | ParenthesisExpr
          | ConcatExpr
          | Identifier
          | Instruction { extends=Expr }

PreFactor ::= DefineCall | Primary { extends=Expr }
Factor ::= PreFactor | (UnaryOp Factor) { extends=Expr }
Term0 ::= Factor (MultOp Factor)* { extends=Expr }
Term1 ::= Term0 (PlusOp Term0)* { extends=Expr }
Term2 ::= Term1 (BitShiftOp Term1)* { extends=Expr }
Term3 ::= Term2 (BITWISE_AND Term2)* { extends=Expr }
Term4 ::= Term3 (BITWISE_XOR Term3)* { extends=Expr }
Term5 ::= Term4 (BITWISE_OR Term4)* { extends=Expr }
Term6 ::= Term5 (LOGICAL_AND Term5)* { extends=Expr }
Term7 ::= Term6 (LOGICAL_XOR Term6)* { extends=Expr }
Term8 ::= Term7 (LOGICAL_OR Term7)* { extends=Expr }
Expr ::= Term8 { extends=Expr }
ParenthesisExpr ::= ROUND_L Expr ROUND_R { pin(".*")=1 extends=Expr }
ConcatExpr ::= (Identifier | DECIMAL | COLON) (TOKEN_CONCAT ConcatExpr)*    // TODO: add more rules for concat

DefineCall ::= Identifier ROUND_L DefineCallArgsList ROUND_R { pin=2 extends=Expr }
DefineCallArgsList ::= DefineCallArg (SEPARATOR DefineCallArg)*

MacroCall ::= Identifier MacroCallArgs { extends=Expr }
MacroCallArgs ::= (MacroCallArg | MacroCallArgSeq) (SEPARATOR (MacroCallArg | MacroCallArgSeq))*
MacroCallArgSeq ::= CURLY_L MacroCallArg (SEPARATOR MacroCallArg)* CURLY_R { pin=1 recoverWhile=MacroCallArgSeqRecover }
private MacroCallArgSeqRecover ::= !(COMMENT | EOL)
MacroCallArg ::= Expr { extends=Expr }
DefineCallArg ::= Expr { extends=Expr }

NumericLiteral ::= BINARY|ZEROES|HEXADECIMAL|DECIMAL|FLOAT_DECIMAL|Char { extends=Expr }
Str ::= STRING { extends=Expr methods=[isValid] }
Char ::= CHARACTER { extends=Expr methods=[isValid] }
BlockComment ::= COMMENT (EOL COMMENT)+ { pin=2 }
