{
  parserClass = "com.andreybotanic.asm.nasm.parser.NasmParser"

  extends = "com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix = "Nasm"
  psiImplClassSuffix = "Impl"
  psiPackage = "com.andreybotanic.asm.nasm.psi"
  psiImplPackage = "com.andreybotanic.asm.nasm.psi.impl"

  elementTypeHolderClass = "com.andreybotanic.asm.nasm.psi.NasmTypes"
  elementTypeClass = "com.andreybotanic.asm.nasm.psi.NasmElementType"
  tokenTypeClass = "com.andreybotanic.asm.nasm.psi.NasmTokenType"

  psiImplUtilClass = "com.andreybotanic.asm.nasm.psi.impl.NasmPsiImplUtil"

  tokens = [
    // Most tokens I get from https://github.com/ajkhoury/JetBrains-NASM-Language/blob/master/src/com/nasmlanguage/NASM.bnf

    WHITE_SPACE         = 'regexp:[ \t\x0B\f]+'
    EOL                 = 'regexp:\R'

    // Preprocessor tags
    INCLUDE_TAG         = 'regexp:(%(\s+)?)([iI][nN][cC][lL][uU][dD][eE])'
    DEFINE_TAG          = 'regexp:(%(\s+)?)(([xX]|[iI])?[dD][eE][fF][iI][nN][eE])'
    ASSIGN_TAG          = 'regexp:(%(\s+)?)([iI]?[aA][sS][sS][iI][gG][nN])'

    DATA_DEF            = 'regexp:[dD][bBwWdDqQtToOyYzZ]'
    DATA_RES            = 'regexp:[rR][eE][sS][bBwWdDqQtToOyYzZ]'

    COMMENT             = 'regexp:;[^\r\n]*'

    SECTION_DEF         = 'regexp:section|segment'
    SECTION_NAME        = 'regexp:\.(text|data|bss)'

    DIRECTIVE_OP        = 'regexp:(bits |use|code)(16|32)|absolute|external|global|org|align|struc|endstruc|common|cpu|group|uppercase|import|library|module'
    END_DIRECTIVE_OP    = 'regexp:end'

    // Registers
    REG_8               = 'regexp:[aAbBcCdD][hHlL]'
    REG_16              = 'regexp:[aAbBcCdD][xX]'
    REG_32              = 'regexp:[eE][aAbBcCdD][xX]'
    REG_64              = 'regexp:[rR][aAbBcCdD][xX]'

    // Instruction operation prefixes
    OP_PREFIX           = 'regexp:((rep(n?[ez])|rep)|lock|bnd|xacquire|xrelease)'
    SIZE_PREFIX         = 'regexp:byte|word|dword|qword'

    GENERAL_OP          = 'regexp:mov|xor|add|inc|dec|jmp'

    // Make last!
    ID                  = 'regexp:([a-zA-Z_?]+[a-zA-Z0-9_$.#@~?]*)' // Some identifier
    LBL_DEF             = 'regexp:([a-zA-Z$._?#@]+[a-zA-Z0-9$._~]*):' // Label definition
    LBL                 = 'regexp:([a-zA-Z$._?#@]+[a-zA-Z0-9$._~]*)' // Label can have chars like % . ? @ # ~ etc

    // Literals
    BINARY              = 'regexp:[1][01]*b'
    HEXADECIMAL         = 'regexp:(0x[0-9A-Fa-f]+)|([0-9A-Fa-f]+h)'
    ZEROES              = 'regexp:[0]+'
    DECIMAL             = 'regexp:((0[dD])?[0-9]+)'
    FLOAT_DECIMAL       = 'regexp:(([0-9]*\.[^A-Za-z][0-9]*)([Ee][+-]?[0-9]+)?)'
    CHARACTER           = "regexp:(`([^`\\]|\\.)`|'([^'\\]|\\.)')"
    STRING              = "regexp:(`([^`\\]|\\.)*`|'([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"

    COLON               = ':'
    SEMICOLON           = ';'
    SQUARE_L            = '['
    SQUARE_R            = ']'
    ROUND_L             = '('
    ROUND_R             = ')'
    CURLY_L             = '{'
    CURLY_R             = '}'
    SEPARATOR           = ','
    DOT                 = '.'
    QUESTION            = '?'

    EQUAL               = '='
    EQUALEQUAL          = '=='
    NOTEQUAL            = '!='
    GREATERTHAN         = '>'
    LESSTHAN            = '<'
    GREATERTHANOREQUAL  = '>='
    LESSTHANOREQUAL     = '<='

    PLUS                = '+'
    MINUS               = '-'
    TIMES               = '*'
    DIVIDE              = '/'
    BITSHIFT_L          = '<<'
    BITSHIFT_R          = '>>'
    BITWISE_AND         = '&'
    BITWISE_OR          = '|'
    BITWISE_XOR         = '^'
    BITWISE_NOT         = '~'
    LOGICAL_AND         = '&&'
    LOGICAL_OR          = '||'
    LOGICAL_XOR         = '^^'

    DOLLARSIGN          = '$'
    DOLLARSIGN2         = '$$'
    PERCENT             = '%'
    PERCENT2            = '%%'
    TOKEN_CONCAT        = '%+'

  ]

  //extends(".*Expr") = Expr
}

NasmFile ::= item_*

private item_ ::= COMMENT
                | Section
                | Label
                | Preprocessor
                | Directive
                | Instruction
                | DataElement
                | MacroCall
                | Identifier
                | EOL
                ;

Preprocessor ::= Include
               | Assign
               | Define
               ;

private InlineItem ::= ConstExpr | Label | Instruction | DataElement | MacroCall | Identifier  { extends=ConstExpr }

Include ::= INCLUDE_TAG STRING
Define ::= (DEFINE_TAG Identifier DefineParams InlineItem )
         | (DEFINE_TAG Identifier InlineItem ) { pin=1 recoverWhile=DefineRecover }
DefineParams ::= ROUND_L Identifier (SEPARATOR Identifier)* ROUND_R { pin=1 recoverWhile=DefineParamsRecover }
private DefineRecover ::= !(EOL | COMMENT)
private DefineParamsRecover ::= !(EOL | COMMENT | Expr)
Assign ::= ASSIGN_TAG Identifier ConstExpr { pin=1 }

Section ::= SECTION_DEF SECTION_NAME

Immediate ::= ConstExpr
Memory ::= Identifier | Address
Address ::= SIZE_PREFIX? AddressInternal { extends=Expr }
private AddressInternal ::= SQUARE_L MINUS? Expr SQUARE_R { pin(".*")=1  }

Register ::= REG_8 | REG_16 | REG_32 | REG_64 { extends=Expr }

Instruction ::= Operation Operands? COMMENT?

Operation ::= GENERAL_OP { extends=Expr }

private Operands ::= Operand (SEPARATOR Operand)* { pin=1 recoverWhile=OperandRecover }
private OperandRecover ::= !(COMMENT | EOL)

Operand ::= Register
          | DefineCall
          | Immediate
          | Memory
          | MacroCall
          | LabelIdentifier
          ;

Label ::= LBL_DEF EOL* {
    mixin       = "com.andreybotanic.asm.nasm.psi.impl.NasmNamedElementImpl"
    implements  = "com.andreybotanic.asm.nasm.psi.NasmNamedElement"
    methods     = [getName setName getNameIdentifier]
}

Identifier ::= ID {
    mixin       = "com.andreybotanic.asm.nasm.psi.impl.NasmNamedElementImpl"
    implements  = "com.andreybotanic.asm.nasm.psi.NasmNamedElement"
    methods     = [getName setName getNameIdentifier getReferences]
    extends     = ConstExpr
}

LabelIdentifier ::= LBL | ID {
    mixin       = "com.andreybotanic.asm.nasm.psi.impl.NasmNamedElementImpl"
    implements  = "com.andreybotanic.asm.nasm.psi.NasmNamedElement"
    methods     = [getName setName getNameIdentifier getReferences]
    extends     = ConstExpr
}

DataElement ::= LBL_DEF? DataStmt EOL*
DataDefStmt ::= DATA_DEF Expr (SEPARATOR Expr)* { pin=1 recoverWhile=DataValueRecover }
DataResStmt ::= DATA_RES Expr
private DataStmt ::= DataResStmt | DataDefStmt
private DataValueRecover ::= !(COMMENT | EOL)

Directive ::= (DirectiveDecl|DirectiveDeclBrackets) EOL*
private DirectiveDecl ::= DIRECTIVE_OP (Expr SEPARATOR?)*
private DirectiveDeclBrackets ::= SQUARE_L DIRECTIVE_OP Expr* SQUARE_R

Expr ::= ParenthesisExpr
       | MulGroupExpr
       | PlusGroupExpr
       | ModulusExpr
       | BitShiftGroupExpr
       | BitwiseANDExpr
       | BitwiseORExpr
       | BitwiseXORExpr
       | BitwiseNOTExpr
       | LogicalANDExpr
       | LogicalORExpr
       | LogicalXORExpr
       | NumericLiteral
       | Str
       | Address
       | Register
       | Operation
       | Identifier
       | LabelIdentifier
       ;

ConstExpr ::= ConstParenthesisExpr
            | ConstMulGroupExpr
            | ConstPlusGroupExpr
            | ConstModulusExpr
            | ConstBitShiftGroupExpr
            | ConstBitwiseANDExpr
            | ConstBitwiseORExpr
            | ConstBitwiseXORExpr
            | ConstBitwiseNOTExpr
            | ConstLogicalANDExpr
            | ConstLogicalORExpr
            | ConstLogicalXORExpr
            | Identifier
            | NumericLiteral
            | Str
            ;

DefineCall ::= Identifier DefineCallParams
DefineCallParams ::= ROUND_L ConstExpr (SEPARATOR ConstExpr)* ROUND_R { pin=1 recoverWhile=DefineCallParamsRecover }
private DefineCallParamsRecover ::= !(EOL | COMMENT | Expr)
MacroCall ::= Identifier MacroCallArgs { extends=ConstExpr }
MacroCallArgs ::= (MacroCallArg | MacroCallArgSeq) (SEPARATOR (MacroCallArg | MacroCallArgSeq))*
MacroCallArgSeq ::= CURLY_L MacroCallArg (SEPARATOR MacroCallArg)* CURLY_R { pin=1 recoverWhile=MacroCallArgSeqRecover }
private MacroCallArgSeqRecover ::= !(COMMENT | EOL)
MacroCallArg ::= ConstExpr

ParenthesisExpr ::= ROUND_L Expr ROUND_R { pin(".*")=1 }
ConstParenthesisExpr ::= ROUND_L ConstExpr ROUND_R { pin(".*")=1 extends=ConstExpr }

ConstMulExpr ::= ConstExpr TIMES ConstExpr { extends=ConstExpr }
ConstDivExpr ::= ConstExpr DIVIDE ConstExpr { extends=ConstExpr }
private ConstMulGroupExpr ::= ConstMulExpr | ConstDivExpr { extends=ConstExpr }
ConstPlusExpr ::= ConstExpr PLUS ConstExpr { extends=ConstExpr }
ConstMinusExpr ::= ConstExpr MINUS ConstExpr { extends=ConstExpr }
private ConstPlusGroupExpr ::= ConstPlusExpr | ConstMinusExpr { extends=ConstExpr }
ConstModulusExpr ::= ConstExpr PERCENT ConstExpr { extends=ConstExpr }
ConstBitShiftLExpr ::= ConstExpr BITSHIFT_L ConstExpr { extends=ConstExpr }
ConstBitShiftRExpr ::= ConstExpr BITSHIFT_R ConstExpr { extends=ConstExpr }
private ConstBitShiftGroupExpr ::= ConstBitShiftLExpr | ConstBitShiftRExpr { extends=ConstExpr }
ConstBitwiseANDExpr ::= ConstExpr BITWISE_AND ConstExpr { extends=ConstExpr }
ConstBitwiseORExpr ::= ConstExpr BITWISE_OR ConstExpr { extends=ConstExpr }
ConstBitwiseXORExpr ::= ConstExpr BITWISE_XOR ConstExpr { extends=ConstExpr }
ConstBitwiseNOTExpr ::= BITWISE_NOT ConstExpr { extends=ConstExpr }
ConstLogicalANDExpr ::= ConstExpr LOGICAL_AND ConstExpr { extends=ConstExpr }
ConstLogicalORExpr ::= ConstExpr LOGICAL_OR ConstExpr { extends=ConstExpr }
ConstLogicalXORExpr ::= ConstExpr LOGICAL_XOR ConstExpr { extends=ConstExpr }

MulExpr ::= Expr TIMES Expr
DivExpr ::= Expr DIVIDE Expr
private MulGroupExpr ::= MulExpr | DivExpr
PlusExpr ::= Expr PLUS Expr
MinusExpr ::= Expr MINUS Expr
private PlusGroupExpr ::= PlusExpr | MinusExpr
ModulusExpr ::= Expr PERCENT Expr
BitShiftLExpr ::= Expr BITSHIFT_L Expr
BitShiftRExpr ::= Expr BITSHIFT_R Expr
private BitShiftGroupExpr ::= BitShiftLExpr | BitShiftRExpr
BitwiseANDExpr ::= Expr BITWISE_AND Expr
BitwiseORExpr ::= Expr BITWISE_OR Expr
BitwiseXORExpr ::= Expr BITWISE_XOR Expr
BitwiseNOTExpr ::= BITWISE_NOT Expr
LogicalANDExpr ::= Expr LOGICAL_AND Expr
LogicalORExpr ::= Expr LOGICAL_OR Expr
LogicalXORExpr ::= Expr LOGICAL_XOR Expr

NumericLiteral ::= SIZE_PREFIX? (BITWISE_NOT|MINUS|PLUS)? (BINARY|ZEROES|HEXADECIMAL|DECIMAL|FLOAT_DECIMAL|CHARACTER) { extends=ConstExpr }
Str ::= STRING { extends=ConstExpr }