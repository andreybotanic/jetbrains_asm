{
  parserClass = "com.andreybotanic.asm.nasm.parser.NasmParser"

  extends = "com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix = "Nasm"
  psiImplClassSuffix = "Impl"
  psiPackage = "com.andreybotanic.asm.nasm.psi"
  psiImplPackage = "com.andreybotanic.asm.nasm.psi.impl"

  elementTypeHolderClass = "com.andreybotanic.asm.nasm.psi.NasmTypes"
  elementTypeClass = "com.andreybotanic.asm.nasm.psi.NasmElementType"
  tokenTypeClass = "com.andreybotanic.asm.nasm.psi.NasmTokenType"

  psiImplUtilClass = "com.andreybotanic.asm.nasm.psi.impl.NasmPsiImplUtil"

  tokens = [
    // Most tokens I get from https://github.com/ajkhoury/JetBrains-NASM-Language/blob/master/src/com/nasmlanguage/NASM.bnf

    WHITE_SPACE         = 'regexp:[ \t\x0B\f]+'
    EOL                 = 'regexp:\R'

    // Preprocessor tags
    INCLUDE_TAG         = 'regexp:([#%](\s+)?)([iI][nN][cC][lL][uU][dD][eE])'
    DEFINE_TAG          = 'regexp:([#%](\s+)?)(([xX]|[iI])?[dD][eE][fF][iI][nN][eE])'
    ASSIGN_TAG          = 'regexp:([#%](\s+)?)([iI]?[aA][sS][sS][iI][gG][nN])'

    DATA_DEF            = 'regexp:d[bwdqtoyz]'
    DATA_RES            = 'regexp:res[bwdqtoyz]'

    COMMENT             = 'regexp:;[^\r\n]*'

    SECTION_DEF         = 'regexp:section|segment'
    SECTION_NAME        = 'regexp:\.(text|data|bss)'

    DIRECTIVE_OP        = 'regexp:(bits |use|code)(16|32)|absolute|external|global|org|align|struc|endstruc|common|cpu|group|uppercase|import|library|module'
    END_DIRECTIVE_OP    = 'regexp:end'

    // Registers
    REG_8               = 'regexp:[abcd][hl]'
    REG_16              = 'regexp:[abcd]x'
    REG_32              = 'regexp:e[abcd]x'
    REG_64              = 'regexp:r[abcd]x'

    // Instruction operation prefixes
    OP_PREFIX           = 'regexp:((rep(n?[ez])|rep)|lock|bnd|xacquire|xrelease)'
    SIZE_PREFIX         = 'regexp:byte|word|dword|qword'

    GENERAL_OP          = 'regexp:mov|xor|add|inc|dec|jmp'

    // Make last!
    ID                  = 'regexp:([a-zA-Z_?]+[a-zA-Z0-9_$.#@~?]*)' // Some identifier
    LBL_DEF             = 'regexp:([a-zA-Z$._?#@]+[a-zA-Z0-9$._~]*):' // Label definition
    LBL                 = 'regexp:([a-zA-Z$._?#@]+[a-zA-Z0-9$._~]*)' // Label can have chars like % . ? @ # ~ etc

    // Literals
    BINARY              = 'regexp:[1][01]*b'
    HEXADECIMAL         = 'regexp:(0x[0-9A-Fa-f]+)|([0-9A-Fa-f]+h)'
    ZEROES              = 'regexp:[0]+'
    DECIMAL             = 'regexp:((0[dD])?[0-9]+)'
    FLOAT_DECIMAL       = 'regexp:(([0-9]*\.[^A-Za-z][0-9]*)([Ee][+-]?[0-9]+)?)'
    CHARACTER           = "regexp:(`([^`\\]|\\.)`|'([^'\\]|\\.)')"
    STRING              = "regexp:(`([^`\\]|\\.)*`|'([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"

    COLON               = ':'
    SEMICOLON           = ';'
    SQUARE_L            = '['
    SQUARE_R            = ']'
    ROUND_L             = '('
    ROUND_R             = ')'
    SEPARATOR           = ','
    DOT                 = '.'
    QUESTION            = '?'

    EQUAL               = '='
    EQUALEQUAL          = '=='
    NOTEQUAL            = '!='
    GREATERTHAN         = '>'
    LESSTHAN            = '<'
    GREATERTHANOREQUAL  = '>='
    LESSTHANOREQUAL     = '<='

    PLUS                = '+'
    MINUS               = '-'
    TIMES               = '*'
    DIVIDE              = '/'
    BITSHIFT_L          = '<<'
    BITSHIFT_R          = '>>'
    BITWISE_AND         = '&'
    BITWISE_OR          = '|'
    BITWISE_XOR         = '^'
    BITWISE_NOT         = '~'
    LOGICAL_AND         = '&&'
    LOGICAL_OR          = '||'
    LOGICAL_XOR         = '^^'

    DOLLARSIGN          = '$'
    DOLLARSIGN2         = '$$'
    PERCENT             = '%'
    PERCENT2            = '%%'
    TOKEN_CONCAT        = '%+'

  ]

  extends(".*Expr") = Expr
}

NasmFile ::= item_*

private item_ ::= COMMENT
                | Section
                | Label
                | Preprocessor
                | Directive
                | Instruction
                | DataElement
                | EOL
                | ID
                ;

Preprocessor ::= Include
               | Assign
               ;
Include ::= INCLUDE_TAG STRING
Assign ::= ASSIGN_TAG Identifier Expr

Section ::= SECTION_DEF SECTION_NAME

Immediate ::= Expr | Str
Memory ::= Identifier | Address
Address ::= SIZE_PREFIX? AddressInternal { extends=Expr }
private AddressInternal ::= SQUARE_L MINUS? Expr SQUARE_R { pin(".*")=1  }

Register ::= REG_8 | REG_16 | REG_32 | REG_64 { extends=Expr }

Instruction ::= Operation Operands? COMMENT? (<<eof>> | EOL+)?

Operation ::= GENERAL_OP { extends=Expr }

private Operands ::= Operand (SEPARATOR Operand)* { pin=1 recoverWhile=OperandRecover }
private OperandRecover ::= !(COMMENT | EOL)

Operand ::= Register
          | Immediate
          | Memory
          | Identifier
          | LabelIdentifier
          ;

Label ::= LBL_DEF EOL* {
    mixin       = "com.andreybotanic.asm.nasm.psi.impl.NasmNamedElementImpl"
    implements  = "com.andreybotanic.asm.nasm.psi.NasmNamedElement"
    methods     = [getName setName getNameIdentifier]
}

Identifier ::= ID {
    mixin       = "com.andreybotanic.asm.nasm.psi.impl.NasmNamedElementImpl"
    implements  = "com.andreybotanic.asm.nasm.psi.NasmNamedElement"
    methods     = [getName setName getNameIdentifier getReferences]
    extends     = Expr
}

LabelIdentifier ::= LBL | ID {
    mixin       = "com.andreybotanic.asm.nasm.psi.impl.NasmNamedElementImpl"
    implements  = "com.andreybotanic.asm.nasm.psi.NasmNamedElement"
    methods     = [getName setName getNameIdentifier getReferences]
    extends     = Expr
}

DataElement ::= LBL_DEF? DataStmt EOL*
DataDefStmt ::= DATA_DEF Expr (SEPARATOR Expr)* { pin=1 recoverWhile=DataValueRecover }
DataResStmt ::= DATA_RES Expr
DataStmt ::= DataResStmt | DataDefStmt
private DataValueRecover ::= !(COMMENT | EOL)

Directive ::= (DirectiveDecl|DirectiveDeclBrackets) EOL*
private DirectiveDecl ::= DIRECTIVE_OP (Expr SEPARATOR?)*
private DirectiveDeclBrackets ::= SQUARE_L DIRECTIVE_OP Expr* SQUARE_R

Expr ::= ParenthesisExpr
       | MulGroupExpr
       | PlusGroupExpr
       | ModulusExpr
       | BitShiftGroupExpr
       | BitwiseANDExpr
       | BitwiseORExpr
       | BitwiseXORExpr
       | BitwiseNOTExpr
       | LogicalANDExpr
       | LogicalORExpr
       | LogicalXORExpr
       | NumericLiteral
       | Str
       | Address
       | Register
       | Operation
       | Identifier
       | LabelIdentifier
       ;

ParenthesisExpr ::= ROUND_L Expr ROUND_R { pin(".*")=1 }

MulExpr ::= Expr TIMES Expr
DivExpr ::= Expr DIVIDE Expr
private MulGroupExpr ::= MulExpr | DivExpr
PlusExpr ::= Expr PLUS Expr
MinusExpr ::= Expr MINUS Expr
private PlusGroupExpr ::= PlusExpr | MinusExpr
ModulusExpr ::= Expr PERCENT Expr
BitShiftLExpr ::= Expr BITSHIFT_L Expr
BitShiftRExpr ::= Expr BITSHIFT_R Expr
private BitShiftGroupExpr ::= BitShiftLExpr | BitShiftRExpr
BitwiseANDExpr ::= Expr BITWISE_AND Expr
BitwiseORExpr ::= Expr BITWISE_OR Expr
BitwiseXORExpr ::= Expr BITWISE_XOR Expr
BitwiseNOTExpr ::= BITWISE_NOT Expr
LogicalANDExpr ::= Expr LOGICAL_AND Expr
LogicalORExpr ::= Expr LOGICAL_OR Expr
LogicalXORExpr ::= Expr LOGICAL_XOR Expr

NumericLiteral ::= SIZE_PREFIX? (BITWISE_NOT|MINUS|PLUS)? (BINARY|ZEROES|HEXADECIMAL|DECIMAL|FLOAT_DECIMAL|CHARACTER) { extends=Expr }
Str ::= STRING { extends=Expr }